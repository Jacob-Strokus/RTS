// Partial Combat module for Simulator
using System.Collections.Generic;
namespace FrontierAges.Sim {
    public partial class Simulator {
        private void CombatStep() {
            for(int i=0;i<State.UnitCount;i++){
                ref var u = ref State.Units[i]; ref var utd = ref State.UnitTypes[u.TypeId]; if(utd.AttackDamageBase<=0) continue;
                if(u.AttackCooldownMs>0){ u.AttackCooldownMs-=SimConstants.MsPerTick; if(u.AttackCooldownMs<0) u.AttackCooldownMs=0; }
                if(u.AttackWindupRemainingMs>0){ u.AttackWindupRemainingMs-=SimConstants.MsPerTick; if(u.AttackWindupRemainingMs<=0){ ResolveAttackLaunch(ref u, ref utd); } continue; }
                int targetIdx = AcquireTargetFor(ref u, utd.AttackRange);
                if(targetIdx>=0 && u.AttackCooldownMs==0){ u.AttackTargetId = State.Units[targetIdx].Id; u.AttackWindupRemainingMs = utd.AttackWindupMs; if(utd.AttackWindupMs==0) ResolveAttackLaunch(ref u, ref utd); }
            }
            UpdateProjectiles();
            ProcessPendingImpacts();
        }
        private struct PendingImpact { public int TickDue; public int AttackerUnitId; public int TargetUnitId; public int Damage; public DamageType DType; }
        private List<PendingImpact> _pendingImpacts = new List<PendingImpact>(256);
        private void QueueImpact(int msDelay, int attackerId, int targetId, int damage, DamageType dt){ if(msDelay<=0){ ApplyDamageToUnit(attackerId, FindUnitIndex(targetId), damage, dt); return; } int dueTick = State.Tick + (msDelay + SimConstants.MsPerTick -1)/SimConstants.MsPerTick; _pendingImpacts.Add( new PendingImpact{ TickDue=dueTick, AttackerUnitId=attackerId, TargetUnitId=targetId, Damage=damage, DType=dt}); }
        private void ProcessPendingImpacts(){ for(int i=0;i<_pendingImpacts.Count;){ var p = _pendingImpacts[i]; if(State.Tick >= p.TickDue){ int tIdx = FindUnitIndex(p.TargetUnitId); if(tIdx>=0) ApplyDamageToUnit(p.AttackerUnitId, tIdx, p.Damage, p.DType); _pendingImpacts[i] = _pendingImpacts[_pendingImpacts.Count-1]; _pendingImpacts.RemoveAt(_pendingImpacts.Count-1); continue; } i++; } }
        private void ResolveAttackLaunch(ref Unit attacker, ref UnitTypeData utd){ attacker.AttackCooldownMs = utd.AttackCooldownMs; int tIdx = FindUnitIndex(attacker.AttackTargetId); if(tIdx<0) return; ref var target = ref State.Units[tIdx]; if(target.FactionId==attacker.FactionId) return; ref var targetData = ref State.UnitTypes[target.TypeId]; int baseD = utd.AttackDamageBase; DamageType bestDt = DamageType.Melee; int bestFinal=1; void Consider(DamageType dt, float mult, int armor){ if(mult<=0f) return; double raw = baseD * mult; int final = (int)System.Math.Max(1, System.Math.Round(raw - armor)); if(final>bestFinal){ bestFinal=final; bestDt=dt; } } Consider(DamageType.Melee, utd.DTMelee<=0?1f:utd.DTMelee, targetData.ArmorMelee); Consider(DamageType.Pierce, utd.DTPierce, targetData.ArmorPierce); Consider(DamageType.Siege, utd.DTSiege, targetData.ArmorSiege); Consider(DamageType.Magic, utd.DTMagic, targetData.ArmorMagic); if(utd.HasProjectile==1){ SpawnProjectile(attacker.X, attacker.Y, target.Id, attacker.Id, bestFinal, bestDt, utd.ProjectileSpeed, utd.ProjectileLifetimeMs, attacker.FactionId, (short)attacker.TypeId); } else { QueueImpact(utd.AttackImpactDelayMs, attacker.Id, target.Id, bestFinal, bestDt); } }
        private int AcquireTargetFor(ref Unit u, int range){ int best=-1; long bestD=long.MaxValue; long r2=(long)range*range; if(u.AttackTargetId!=0){ int idx=FindUnitIndex(u.AttackTargetId); if(idx>=0){ ref var tu=ref State.Units[idx]; if(tu.FactionId!=u.FactionId){ long dx=tu.X-u.X; long dy=tu.Y-u.Y; long d2=dx*dx+dy*dy; if(d2<=r2) return idx; } else u.AttackTargetId=0; } } for(int j=0;j<State.UnitCount;j++){ ref var t = ref State.Units[j]; if(t.FactionId==u.FactionId || t.HP<=0) continue; long dx=t.X-u.X; long dy=t.Y-u.Y; long d2=dx*dx+dy*dy; if(d2<=r2 && d2<bestD){ bestD=d2; best=j; } } return best; }
        private void ApplyDamageToUnit(int attackerId, int unitIndex, int rawDamage, DamageType dtype){ if(unitIndex<0||unitIndex>=State.UnitCount) return; ref var target = ref State.Units[unitIndex]; int tid = target.Id; ref var utd = ref State.UnitTypes[target.TypeId]; int armor=0; switch(dtype){ case DamageType.Melee: armor=utd.ArmorMelee; break; case DamageType.Pierce: armor=utd.ArmorPierce; break; case DamageType.Siege: armor=utd.ArmorSiege; break; case DamageType.Magic: armor=utd.ArmorMagic; break; } int final = rawDamage - armor; if(final<1) final=1; target.HP -= final; byte wasKill = 0; if(target.HP<=0){ wasKill=1; RemoveUnitByIndex(unitIndex); } _damageEvents.Add(new DamageEvent{ Tick=State.Tick, AttackerUnitId=attackerId, TargetUnitId=tid, Damage=final, DType=dtype, TargetX=target.X, TargetY=target.Y, WasKill=wasKill}); }
        private void UpdateProjectiles(){ for(int i=0;i<State.ProjectileCount;){ ref var p = ref State.Projectiles[i]; p.LifetimeMs -= SimConstants.MsPerTick; if(p.LifetimeMs<=0){ RemoveProjectileAt(i); continue; } int targetIdx = FindUnitIndex(p.TargetUnitId); if(targetIdx>=0){ ref var tu = ref State.Units[targetIdx]; int speedPerTick = p.Speed * SimConstants.MsPerTick / 1000; int dx = tu.X - p.X; int dy = tu.Y - p.Y; long d2=(long)dx*dx + (long)dy*dy; if(d2 <= 400L*400L){ ApplyDamageToUnit(p.AttackerUnitId, targetIdx, p.Damage, p.DType); RemoveProjectileAt(i); continue; } int dist = IntegerSqrt(d2); if(dist>0){ p.X += dx * speedPerTick / dist; p.Y += dy * speedPerTick / dist; } } else { RemoveProjectileAt(i); continue; } State.Projectiles[i]=p; i++; } }
        private void SpawnProjectile(int x, int y, int targetUnitId, int attackerUnitId, int damage, DamageType dt, int speed, int lifetimeMs, int factionId, short sourceType){ if(State.ProjectileCount>=State.Projectiles.Length){ var arr=new Projectile[State.Projectiles.Length*2]; System.Array.Copy(State.Projectiles,arr,State.Projectiles.Length); State.Projectiles=arr; } int id = (State.Tick<<10)|State.ProjectileCount; State.Projectiles[State.ProjectileCount++] = new Projectile{ Id=id, X=x, Y=y, TargetUnitId=targetUnitId, AttackerUnitId=attackerUnitId, AttackSourceTypeId=sourceType, FactionId=factionId, Speed=speed, Damage=damage, DType=dt, LifetimeMs=lifetimeMs}; }
        private void RemoveProjectileAt(int idx){ State.ProjectileCount--; if(idx!=State.ProjectileCount){ State.Projectiles[idx]=State.Projectiles[State.ProjectileCount]; }}
    }
}
